// Copyright (c) 2025 ReactiveUI and contributors. All rights reserved.
// Licensed to the ReactiveUI and contributors under one or more agreements.
// The ReactiveUI and contributors licenses this file to you under the MIT license.
// See the LICENSE file in the project root for full license information.

using System.Linq;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using ReactiveUI.SourceGenerators.Extensions;
using ReactiveUI.SourceGenerators.Helpers;
using ReactiveUI.SourceGenerators.Models;

namespace ReactiveUI.SourceGenerators;

/// <summary>
/// A source generator for generating reactiveObject properties.
/// </summary>
public partial class ReactiveObjectGenerator
{
    internal static readonly string GeneratorName = typeof(ReactiveObjectGenerator).FullName!;
    internal static readonly string GeneratorVersion = typeof(ReactiveObjectGenerator).Assembly.GetName().Version.ToString();

    private static ReactiveObjectInfo? GetClassInfo(in GenericGeneratorAttributeSyntaxContext context, CancellationToken token)
    {
        if (!(context.TargetNode is ClassDeclarationSyntax declaredClass && declaredClass.Modifiers.Any(SyntaxKind.PartialKeyword)))
        {
            return default;
        }

        var symbol = context.TargetSymbol;
        token.ThrowIfCancellationRequested();

        if (!symbol.TryGetAttributeWithFullyQualifiedMetadataName(AttributeDefinitions.ReactiveObjectAttributeType, out var attributeData))
        {
            return default;
        }

        token.ThrowIfCancellationRequested();
        if (symbol is not INamedTypeSymbol classSymbol)
        {
            return default;
        }

        var constructorArgument = attributeData.GetConstructorArguments<string>().FirstOrDefault();
        var genericArgument = attributeData.GetGenericType();
        token.ThrowIfCancellationRequested();
        var viewModelTypeName = string.IsNullOrWhiteSpace(constructorArgument) ? genericArgument : constructorArgument;
        if (string.IsNullOrWhiteSpace(viewModelTypeName))
        {
            return default;
        }

        token.ThrowIfCancellationRequested();

        // Get the containing type info
        var targetInfo = TargetInfo.From(classSymbol);

        token.ThrowIfCancellationRequested();
        return new(
            targetInfo,
            viewModelTypeName!);
    }

    private static string GenerateSource(string containingTypeName, string containingNamespace, string containingClassVisibility, string containingType, ReactiveObjectInfo reactiveObjectInfo) =>
        $$"""
// <auto-generated/>
#pragma warning disable
#nullable enable
using System;
using System.Diagnostics.CodeAnalysis;
using System.ComponentModel;
using ReactiveUI;

namespace {{containingNamespace}}
{
    /// <summary>
    /// Partial class for the {{containingTypeName}} which contains ReactiveUI IReactiveObject initialization.
    /// </summary>
    {{containingClassVisibility}} partial {{containingType}} {{containingTypeName}} : IReactiveObject
    {
        private bool _propertyChangingEventsSubscribed;
        private bool _propertyChangedEventsSubscribed;

        /// <inheritdoc/>
        public event PropertyChangingEventHandler? PropertyChanging
        {
            add
            {
                if (!_propertyChangingEventsSubscribed)
                {
                    this.SubscribePropertyChangingEvents();
                    _propertyChangingEventsSubscribed = true;
                }

                PropertyChangingHandler += value;
            }
            remove => PropertyChangingHandler -= value;
        }

        /// <inheritdoc/>
        public event PropertyChangedEventHandler? PropertyChanged
        {
            add
            {
                if (!_propertyChangedEventsSubscribed)
                {
                    this.SubscribePropertyChangedEvents();
                    _propertyChangedEventsSubscribed = true;
                }

                PropertyChangedHandler += value;
            }
            remove => PropertyChangedHandler -= value;
        }

        [SuppressMessage("Roslynator", "RCS1159:Use EventHandler<T>", Justification = "Long term design.")]
        private event PropertyChangingEventHandler? PropertyChangingHandler;

        [SuppressMessage("Roslynator", "RCS1159:Use EventHandler<T>", Justification = "Long term design.")]
        private event PropertyChangedEventHandler? PropertyChangedHandler;

        /// <inheritdoc/>
        void IReactiveObject.RaisePropertyChanging(PropertyChangingEventArgs args) =>
            PropertyChangingHandler?.Invoke(this, args);

        /// <inheritdoc/>
        void IReactiveObject.RaisePropertyChanged(PropertyChangedEventArgs args) =>
            PropertyChangedHandler?.Invoke(this, args);
    }
}
#nullable restore
#pragma warning restore
""";
}
