// Copyright (c) 2025 .NET Foundation and Contributors. All rights reserved.
// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for full license information.

// <auto-generated/>
#pragma warning disable
using System;

namespace ReactiveUI.SourceGenerators.Helpers;

internal static class AttributeDefinitions
{
    public const string GeneratedCode = "global::System.CodeDom.Compiler.GeneratedCode";
    public const string Obsolete = "global::System.Obsolete";

    public const string AccessModifierType = "ReactiveUI.SourceGenerators.AccessModifier";
    public static string[] ExcludeFromCodeCoverage = ["[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]"];

    public static string GetAccessModifierEnum() => $$"""
        // Copyright (c) {{DateTime.Now.Year}} .NET Foundation and Contributors. All rights reserved.
        // Licensed to the .NET Foundation under one or more agreements.
        // The .NET Foundation licenses this file to you under the MIT license.
        // See the LICENSE file in the project root for full license information.
        
        // <auto-generated/>
        #pragma warning disable
        #nullable enable
        namespace ReactiveUI.SourceGenerators;

        /// <summary>
        /// AccessModifier.
        /// </summary>
        internal enum AccessModifier
        {
            Public,
            Protected,
            Internal,
            Private,
            InternalProtected,
            PrivateProtected,
            Init,
        }
        
        /// <summary>
        /// Property Access Modifier.
        /// </summary>
        internal enum PropertyAccessModifier
        {
            Public,
            Protected,
            Internal,
            Private,
            InternalProtected,
            PrivateProtected,
        }
        
        /// <summary>
        /// InheritanceModifier.
        /// </summary>
        internal enum InheritanceModifier
        {
            None,
            Virtual,
            Override,
            New,
        }

        internal enum SplatRegistrationType
        {
            None,
            LazySingleton,
            Constant,
            PerRequest,
        }
        #nullable restore
        #pragma warning restore
        """;

    public const string ReactiveObjectAttributeType = "ReactiveUI.SourceGenerators.IReactiveObjectAttribute";

    public static string ReactiveObjectAttribute => $$"""
// Copyright (c) {{DateTime.Now.Year}} .NET Foundation and Contributors. All rights reserved.
// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for full license information.

// <auto-generated/>
#pragma warning disable
#nullable enable
namespace ReactiveUI.SourceGenerators;

/// <summary>
/// IReactiveObject Attribute.
/// </summary>
/// <seealso cref="System.Attribute" />
[global::System.CodeDom.Compiler.GeneratedCode("ReactiveUI.SourceGenerators.ReactiveObjectGenerator", "{{ReactiveGenerator.GeneratorVersion}}")]
[global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
internal sealed class IReactiveObjectAttribute : global::System.Attribute;
#nullable restore
#pragma warning restore
""";

    public const string ReactiveCommandAttributeType = "ReactiveUI.SourceGenerators.ReactiveCommandAttribute";

    /// <summary>
    /// Gets the reactive command attribute.
    /// </summary>
    /// <value>
    /// The reactive command attribute.
    /// </value>
    public static string ReactiveCommandAttribute => $$"""
// Copyright (c) {{DateTime.Now.Year}} .NET Foundation and Contributors. All rights reserved.
// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for full license information.

// <auto-generated/>
#pragma warning disable
#nullable enable
namespace ReactiveUI.SourceGenerators;

/// <summary>
/// ReactiveCommand Attribute.
/// </summary>
/// <seealso cref="Attribute" />
[global::System.CodeDom.Compiler.GeneratedCode("ReactiveUI.SourceGenerators.ReactiveCommandGenerator", "{{ReactiveGenerator.GeneratorVersion}}")]
[global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
internal sealed class ReactiveCommandAttribute : global::System.Attribute
{
    /// <summary>
    /// Gets the can execute method or property.
    /// </summary>
    /// <value>
    /// The name of the CanExecute Observable of bool.
    /// </value>
    public string? CanExecute { get; init; }
    
    /// <summary>
    /// Gets the output scheduler.
    /// </summary>
    /// <value>
    /// The output scheduler.
    /// </value>
    public string? OutputScheduler { get; init; }

    /// <summary>
    /// Gets the AccessModifier of the ReactiveCommand property.
    /// </summary>
    /// <value>
    /// The AccessModifier of the property.
    /// </value>
    public PropertyAccessModifier AccessModifier { get; init; }
}
#nullable restore
#pragma warning restore
""";

    public const string ReactiveAttributeType = "ReactiveUI.SourceGenerators.ReactiveAttribute";

    /// <summary>
    /// Gets the reactive attribute.
    /// </summary>
    /// <value>
    /// The reactive attribute.
    /// </value>
#if ROSYLN_412
    public static string ReactiveAttribute => $$"""
// Copyright (c) {{DateTime.Now.Year}} .NET Foundation and Contributors. All rights reserved.
// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for full license information.

// <auto-generated/>
#pragma warning disable
#nullable enable
namespace ReactiveUI.SourceGenerators;

/// <summary>
/// ReactiveAttribute.
/// </summary>
/// <seealso cref="Attribute" />
[global::System.CodeDom.Compiler.GeneratedCode("{{ReactiveGenerator.GeneratorName}}", "{{ReactiveGenerator.GeneratorVersion}}")]
[global::System.AttributeUsage(global::System.AttributeTargets.Field | global::System.AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
internal sealed class ReactiveAttribute : global::System.Attribute
{
    /// <summary>
    /// Initializes a new instance of the <see cref="ReactiveAttribute"/> class.
    /// </summary>
    public ReactiveAttribute(params string[] alsoNotify)
    {
        AlsoNotify = alsoNotify;
    }

    /// <summary>
    /// Gets the AccessModifier of the set property.
    /// </summary>
    /// <value>
    /// The AccessModifier of the set property.
    /// </value>
    public AccessModifier SetModifier { get; init; }

    /// <summary>
    /// Gets the InheritanceModifier of the property.
    /// </summary>
    public InheritanceModifier Inheritance { get; init; }

    /// <summary>
    /// Use Required attribute to indicate that the property is required.
    /// </summary>
    public bool UseRequired { get; init; }

    /// <summary>
    /// Gets the AlsoNotify properties to raise change notifications for.
    /// </summary>
    public string[]? AlsoNotify { get; }
}
#nullable restore
#pragma warning restore
""";
#else
    public static string ReactiveAttribute => $$"""
// Copyright (c) {{DateTime.Now.Year}} .NET Foundation and Contributors. All rights reserved.
// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for full license information.

// <auto-generated/>
#pragma warning disable
#nullable enable
namespace ReactiveUI.SourceGenerators;

/// <summary>
/// ReactiveAttribute.
/// </summary>
/// <seealso cref="Attribute" />
[global::System.CodeDom.Compiler.GeneratedCode("{{ReactiveGenerator.GeneratorName}}", "{{ReactiveGenerator.GeneratorVersion}}")]
[global::System.AttributeUsage(global::System.AttributeTargets.Field, AllowMultiple = false, Inherited = false)]
internal sealed class ReactiveAttribute : global::System.Attribute
{
    /// <summary>
    /// Initializes a new instance of the <see cref="ReactiveAttribute"/> class.
    /// </summary>
    public ReactiveAttribute(params string[] alsoNotify)
    {
        AlsoNotify = alsoNotify;
    }

    /// <summary>
    /// Gets the AccessModifier of the set property.
    /// </summary>
    /// <value>
    /// The AccessModifier of the set property.
    /// </value>
    public AccessModifier SetModifier { get; init; }

    /// <summary>
    /// Gets the InheritanceModifier of the property.
    /// </summary>
    public InheritanceModifier Inheritance { get; init; }

    /// <summary>
    /// Use Required attribute to indicate that the property is required.
    /// </summary>
    public bool UseRequired { get; init; }

    /// <summary>
    /// Gets the AlsoNotify properties to raise change notifications for.
    /// </summary>
    public string[]? AlsoNotify { get; }
}
#nullable restore
#pragma warning restore
""";
#endif

    public const string ObservableAsPropertyAttributeType = "ReactiveUI.SourceGenerators.ObservableAsPropertyAttribute";
#if ROSYLN_412
    public static string ObservableAsPropertyAttribute => $$"""
// Copyright (c) {{DateTime.Now.Year}} .NET Foundation and Contributors. All rights reserved.
// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for full license information.

// <auto-generated/>
#pragma warning disable
#nullable enable
namespace ReactiveUI.SourceGenerators;

/// <summary>
/// ObservableAsPropertyAttribute.
/// </summary>
/// <seealso cref="Attribute" />
[global::System.CodeDom.Compiler.GeneratedCode("ReactiveUI.SourceGenerators.ObservableAsPropertyGenerator", "{{ReactiveGenerator.GeneratorVersion}}")]
[global::System.AttributeUsage(global::System.AttributeTargets.Field | global::System.AttributeTargets.Property | global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
internal sealed class ObservableAsPropertyAttribute : global::System.Attribute
{
    /// <summary>
    /// Gets the name of the property.
    /// </summary>
    /// <value>
    /// The name of the property.
    /// </value>
    public string? PropertyName { get; init; }

    /// <summary>
    /// Gets the Readonly state of the OAPH property.
    /// </summary>
    /// <value>
    /// The is read only of the OAPH property.
    /// </value>
    public bool ReadOnly { get; init; } = true;

    /// <summary>
    /// Gets the AccessModifier of the OAPH property.
    /// </summary>
    /// <value>
    /// The AccessModifier of the OAPH property, protected if true.
    /// </value>
    public bool UseProtected { get; init; } = false;

    /// <summary>
    /// Gets the Initial value of the OAPH property.
    /// </summary>
    /// <value>
    /// The initial value of the OAPH property.
    /// </value>
    public string? InitialValue { get; init; }
}
#nullable restore
#pragma warning restore
""";
#else
    public static string ObservableAsPropertyAttribute => $$"""
// Copyright (c) {{DateTime.Now.Year}} .NET Foundation and Contributors. All rights reserved.
// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for full license information.

// <auto-generated/>
#pragma warning disable
#nullable enable
namespace ReactiveUI.SourceGenerators;

/// <summary>
/// ObservableAsPropertyAttribute.
/// </summary>
/// <seealso cref="Attribute" />
[global::System.CodeDom.Compiler.GeneratedCode("ReactiveUI.SourceGenerators.ObservableAsPropertyGenerator", "{{ReactiveGenerator.GeneratorVersion}}")]
[global::System.AttributeUsage(global::System.AttributeTargets.Field | global::System.AttributeTargets.Property | global::System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
internal sealed class ObservableAsPropertyAttribute : global::System.Attribute
{
    /// <summary>
    /// Gets the name of the property.
    /// </summary>
    /// <value>
    /// The name of the property.
    /// </value>
    public string? PropertyName { get; init; }

    /// <summary>
    /// Gets the Readonly state of the OAPH property.
    /// </summary>
    /// <value>
    /// The is read only of the OAPH property.
    /// </value>
    public bool ReadOnly { get; init; } = true;

    /// <summary>
    /// Gets the AccessModifier of the OAPH property.
    /// </summary>
    /// <value>
    /// The AccessModifier of the OAPH property, protected if true.
    /// </value>
    public bool UseProtected { get; init; } = false;
}
#nullable restore
#pragma warning restore
""";
#endif
    public const string IViewForAttributeType = "ReactiveUI.SourceGenerators.IViewForAttribute";

    public static string IViewForAttribute => $$"""
// Copyright (c) {{DateTime.Now.Year}} .NET Foundation and Contributors. All rights reserved.
// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for full license information.

// <auto-generated/>
#pragma warning disable
#nullable enable
namespace ReactiveUI.SourceGenerators;

/// <summary>
/// IViewForAttribute.
/// </summary>
/// <seealso cref="System.Attribute" />
/// <remarks>
/// Initializes a new instance of the <see cref="IViewForAttribute"/> class.
/// </remarks>
/// <param name="viewModelType">Type of the view model.</param>
[global::System.CodeDom.Compiler.GeneratedCode("ReactiveUI.SourceGenerators.IViewForGenerator", "{{ReactiveGenerator.GeneratorVersion}}")]
[global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
internal sealed class IViewForAttribute<T> : global::System.Attribute
{
    /// <summary>
    /// Gets the Splat registration type for Splat IViewFor registration.
    /// Registers IViewFor<T> in the Splat service locator.
    /// </summary>
    public SplatRegistrationType RegistrationType { get; init; } = SplatRegistrationType.None;

    /// <summary>
    /// Gets the Splat registration type for Splat View Model registration.
    /// Registers the ViewModel (T) in the Splat service locator.
    /// </summary>
    public SplatRegistrationType ViewModelRegistrationType { get; init; } = SplatRegistrationType.None;
}

/// <summary>
/// IViewForAttribute.
/// </summary>
/// <seealso cref="System.Attribute" />
/// <remarks>
/// Initializes a new instance of the <see cref="IViewForAttribute"/> class.
/// </remarks>
/// <param name="viewModelType">Type of the view model, ensure to use the full type name including namespace.</param>
[global::System.CodeDom.Compiler.GeneratedCode("ReactiveUI.SourceGenerators.IViewForGenerator", "{{ReactiveGenerator.GeneratorVersion}}")]
[global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
internal sealed class IViewForAttribute(string? viewModelType) : global::System.Attribute
{
    /// <summary>
    /// Gets the Splat registration type for Splat IViewFor registration.
    /// Registers IViewFor<T> in the Splat service locator.
    /// </summary>
    public SplatRegistrationType RegistrationType { get; init; } = SplatRegistrationType.None;

    /// <summary>
    /// Gets the Splat registration type for Splat View Model registration.
    /// Registers the ViewModel (T) in the Splat service locator.
    /// </summary>
    public SplatRegistrationType ViewModelRegistrationType { get; init; } = SplatRegistrationType.None;
}
#nullable restore
#pragma warning restore
""";

    public const string ViewModelControlHostAttributeType = "ReactiveUI.SourceGenerators.WinForms.ViewModelControlHostAttribute";

    public static string ViewModelControlHostAttribute => $$"""
// Copyright (c) {{DateTime.Now.Year}} .NET Foundation and Contributors. All rights reserved.
// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for full license information.

// <auto-generated/>
#pragma warning disable
#nullable enable
namespace ReactiveUI.SourceGenerators.WinForms;

/// <summary>
/// ViewModelControlHostAttribute.
/// </summary>
/// <seealso cref="System.Attribute" />
/// <remarks>
/// Initializes a new instance of the <see cref="ViewModelControlHostAttribute"/> class.
/// </remarks>
/// <param name="viewModelType">Type of the view model.</param>
[global::System.CodeDom.Compiler.GeneratedCode("ReactiveUI.SourceGenerators.ViewModelControlHostGenerator", "{{ReactiveGenerator.GeneratorVersion}}")]
[global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
internal sealed class ViewModelControlHostAttribute(string? baseType) : global::System.Attribute;
#nullable restore
#pragma warning restore
""";

    public const string RoutedControlHostAttributeType = "ReactiveUI.SourceGenerators.WinForms.RoutedControlHostAttribute";

    public static string GetRoutedControlHostAttribute() => $$"""
// Copyright (c) {{DateTime.Now.Year}} .NET Foundation and Contributors. All rights reserved.
// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for full license information.

// <auto-generated/>
#pragma warning disable
#nullable enable
namespace ReactiveUI.SourceGenerators.WinForms;

/// <summary>
/// RoutedControlHostAttribute.
/// </summary>
/// <seealso cref="System.Attribute" />
/// <remarks>
/// Initializes a new instance of the <see cref="RoutedControlHostAttribute"/> class.
/// </remarks>
/// <param name="viewModelType">Type of the view model.</param>
[global::System.CodeDom.Compiler.GeneratedCode("ReactiveUI.SourceGenerators.RoutedControlHostGenerator", "{{ReactiveGenerator.GeneratorVersion}}")]
[global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
internal sealed class RoutedControlHostAttribute(string? baseType) : global::System.Attribute;
#nullable restore
#pragma warning restore
""";

    public const string BindableDerivedListAttributeType = "ReactiveUI.SourceGenerators.BindableDerivedListAttribute";

    public static string BindableDerivedListAttribute => $$"""
// Copyright (c) {{DateTime.Now.Year}} .NET Foundation and Contributors. All rights reserved.
// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for full license information.

// <auto-generated/>
#pragma warning disable
#nullable enable
namespace ReactiveUI.SourceGenerators;

/// <summary>
/// ReactiveAttribute.
/// </summary>
/// <seealso cref="Attribute" />
[global::System.CodeDom.Compiler.GeneratedCode("{{ReactiveGenerator.GeneratorName}}", "{{ReactiveGenerator.GeneratorVersion}}")]
[global::System.AttributeUsage(global::System.AttributeTargets.Field, AllowMultiple = false, Inherited = false)]
internal sealed class BindableDerivedListAttribute : global::System.Attribute;
#nullable restore
#pragma warning restore
""";

    public const string ReactiveCollectionAttributeType = "ReactiveUI.SourceGenerators.ReactiveCollectionAttribute";

    public static string ReactiveCollectionAttribute => $$"""
// Copyright (c) {{DateTime.Now.Year}} .NET Foundation and Contributors. All rights reserved.
// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for full license information.

// <auto-generated/>
#pragma warning disable
#nullable enable
namespace ReactiveUI.SourceGenerators;

/// <summary>
/// ReactiveAttribute.
/// </summary>
/// <seealso cref="Attribute" />
[global::System.CodeDom.Compiler.GeneratedCode("{{ReactiveGenerator.GeneratorName}}", "{{ReactiveGenerator.GeneratorVersion}}")]
[global::System.AttributeUsage(global::System.AttributeTargets.Field | global::System.AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
internal sealed class ReactiveCollectionAttribute : global::System.Attribute;
#nullable restore
#pragma warning restore
""";
}

#pragma warning restore
